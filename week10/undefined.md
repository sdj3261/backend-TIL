# 애플리케이션 수준의 보안

### 목차

* 인증과 인가
* HTTP Stateless (1주차 복습)
* Cookie vs localStorage
* Interceptor vs Filter in Spring
* 암호화와 복호화
  * 단방향 암호화
  * Hashing algorithm
  * Salt가 필요한 이유

### 강의 정리

애플리케이션 수준에서 꼭 챙겨야 하는 기본 보안 요소 3가지

1. 인증 (Authentication)
2. 인가 (Authorization)
3. 암호화 (Encryption)

\| 인증과 인가

❓인증&#x20;

`“컴퓨터 보안에서`` `**`인증`**`은 로그인 요청 등을 통해 통신 상에서 보내는 사람의 디지털 정체성을 확인하는 시도의 과정이다.”`

사용자가 누구인가?&#x20;

누구인지 증명하는 것을 인증 과정 이라고 한다.

한번 로그인을 하면 세션이 유지될 동안 다시 로그인을 하지 않아도 된다. 하지만 HTTP는 stateless를 전제로 한다. 각 요청은 개별적이고, 매 요청마다 “나는 누구인가?”라는 질문에 답을 줘야 한다. 즉, 매 요청마다 인증 절차가 있게 된다.

❓인가

인가는 허가이다.

ex) 현재 사용자가 관리자임을 증명해야 하고(인증), 관리자가 아닌 사용자는 관리자 페이지에 접근할 수 없게 해야 한다(인가).

❗인증과 인가 과정

1. 사용자 입장에서는 로그인 페이지를 통해 인증 절차를 밟게 되고, 접근이 거부될 때만 인가 과정이 있었음을 알 수 있게 된다.
2. 클라이언트 입장에서는 로그인 과정을 통해 인증 결과로 허가의 의미로  토큰을 얻게 되고(세션을 활용한다면 Session ID를 통해 간접적으로 전달), 이를 쿠키나 localStorage 등으로 웹 브라우저에서  관리하면서 매 요청마다 서버로 전달한다. 즉, 매 요청마다 인가 과정이 있다고 가정한다.\
   (토큰이 있니? 통과? 아니야? 403)
3. 서버 입장에서는 모든 요청에 대해 인증 작업이 수행된다. 로그인 등을 통해 발행한 토큰 등을 매번 확인해 사용자가 누구인지 알아내고(인증), 해당 사용자가 올바른 접근을 했는지 확인해서 허용 또는 금지한다(인가).

즉 백엔드에선 HTTP 프로토콜의  stateless로 인해 매 요청마다 인증과 인가 과정을 통해 보안 처리를 해야한다.

Spring Web MVC로 개발할 때는 Controller로 요청이 전달되기 전에 HandlerInterceptor로 우리가 원하는 코드를 먼저 실행할 수 있고, Spring Security를 사용하면 SecurityFilterChain을 통해 우리가 원하는 코드를 먼저 실행할 수 있다.



\| Cookie vs localStorage

#### 쿠키 (Cookies)

1. **정의 및 사용**: 쿠키는 클라이언트(브라우저)에 저장되는 작은 데이터 조각입니다. 웹 서버는 HTTP 응답의 일부로 쿠키를 설정하고, 이후의 요청에서 브라우저는 이 쿠키를 웹 서버에 자동으로 반환합니다.
2. **인증 과정에서의 역할**:
   * **세션 쿠키**: 사용자가 로그인하면 서버는 세션 ID를 쿠키에 저장합니다. 이후의 모든 요청에는 이 세션 ID가 포함되어 서버에서 사용자를 식별할 수 있게 합니다.
   * **보안**: 쿠키는 `HttpOnly`와 `Secure` 플래그를 사용하여 각각 XSS 공격으로부터 보호하고, 데이터가 오직 HTTPS를 통해서만 전송되도록 할 수 있습니다.
3. **제한 사항**:
   * 크기 제한: 쿠키는 대략 4KB의 데이터 크기 제한이 있습니다.
   * 보안 문제: 쿠키는 CSRF(Cross-Site Request Forgery) 공격에 취약할 수 있으며, 이를 방지하기 위한 추가적인 보호 조치가 필요합니다.

#### 로컬 스토리지 (Local Storage)

1. **정의 및 사용**: 로컬 스토리지는 웹 브라우저에 데이터를 저장하는 HTML5의 기능으로, 사용자가 브라우저의 캐시를 지우지 않는 이상 데이터가 영구적으로 저장됩니다.
2. **인증 과정에서의 역할**:
   * **토큰 저장**: 사용자가 로그인하면 서버는 인증 토큰(예: JWT, JSON Web Token)을 제공하고, 이를 로컬 스토리지에 저장할 수 있습니다. 이후의 요청에서는 이 토큰을 HTTP 요청 헤더에 포함시켜 서버에 전송합니다.
   * **클라이언트 사이드**: 로컬 스토리지는 클라이언트 측에서만 접근 가능하며, 서버로 자동 전송되지 않습니다.
3. **제한 사항**:
   * 보안 문제: 로컬 스토리지는 XSS 공격에 취약할 수 있습니다. 악의적인 스크립트가 로컬 스토리지에 접근하여 사용자 데이터를 탈취할 수 있습니다.
   * 크기 제한: 약 5MB의 데이터를 저장할 수 있습니다.

\| 암호화

암호화는 평문(원래 값)을 남들이 알기 어렵도록 변환해서 암호문을 만드는 작업이다. 암호문을 다시 평문으로 변환하는 작업은 복호화라고 한다. 일반적으로는 암호문을 평문으로 되돌릴 수 있지만, 평문으로 되돌릴 수 없는 암호화도 있다.

해시 함수는 임의의 길이의 데이터를 고정된 길이의 데이터로 매핑하는 [함수](https://ko.wikipedia.org/wiki/%ED%95%A8%EC%88%98)이다

<figure><img src="../.gitbook/assets/image.png" alt=""><figcaption></figcaption></figure>

암호화와 복호화는 컴퓨터 보안의 핵심 요소입니다. 여기서 중요한 개념 두 가지는 단방향 암호화와 솔트(salt)의 사용입니다.

암호학적 해시함수는 역상(pre-image), 제2역상(2nd pre-image), 충돌쌍(collision)에 대하여 안전성을 가져야 하며 인증에 이용된다 .

1. **역상(Pre-image) 안전성**:
   * 이는 주어진 해시 값에 대해 원본 데이터를 찾아내는 것이 계산상 불가능해야 한다는 것을 의미합니다. 즉, 해시 값 `H`가 주어졌을 때, 원본 데이터 `X`를 찾는 것이 실질적으로 불가능해야 합니다(`H = hash(X)`). 이러한 특성은 해시 함수가 단방향성을 가진다는 것을 보장합니다.
2. **제2역상(Second Pre-image) 안전성**:
   * 제2역상 안전성은 이미 알려진 데이터 `X`에 대해, 그것과 다른 데이터 `Y`를 찾아내서 같은 해시 값을 생성하는 것이 계산상 불가능해야 한다는 것을 의미합니다(`hash(X) = hash(Y)`). 이는 해시 함수가 중복되지 않는 고유한 값을 생성해야 함을 보장합니다.
3. **충돌쌍(Collision) 안전성**:
   * 충돌쌍 안전성은 두 개의 서로 다른 데이터 `X`와 `Y`를 찾아내어 같은 해시 값을 생성하는 것이 매우 어려워야 한다는 것을 의미합니다. 즉, `hash(X) = hash(Y)`인 `X`와 `Y`를 찾는 것이 계산상 매우 어려워야 합니다. 이는 해시 함수가 충돌에 대해 매우 강력한 저항력을 가져야 함을 의미합니다.

이러한 세 가지 안전성은 암호학적 해시 함수가 신뢰성 있고 보안에 적합하도록 하는 데 필수적입니다. 예를 들어, 비밀번호 저장, 데이터 무결성 확인, 디지털 서명 생성 등에서 중요한 역할을 합니다. 이러한 속성들 덕분에 해시 함수는 해킹이나 데이터 조작으로부터 안전하게 정보를 보호하는 데 사용될 수 있습니다.

1. **단방향 암호화 (Hashing Algorithm)**:
   * 단방향 암호화는 정보를 암호화하는 과정이며, 복호화가 불가능합니다. 이는 '해싱 알고리즘'을 통해 이루어집니다. (비가역적)&#x20;
   * 해싱 알고리즘은 데이터를 고정된 길이의 고유한 해시 값으로 변환합니다. 이 해시 값은 원본 데이터를 추정하기 어렵게 만들어, 비밀번호 저장과 같은 보안이 필요한 곳에서 주로 사용됩니다.
2. **솔트 (Salt)의 필요성**:
   * 솔트는 해싱 과정에 추가되는 무작위 데이터 조각입니다. 이는 각 사용자의 비밀번호 해시가 고유하도록 보장합니다.
   * 솔트를 사용하는 이유는 주로 '레인보우 테이블 공격'과 같은 해시 충돌 공격을 방지하기 위함입니다. 레인보우 테이블은 일반적으로 사용되는 비밀번호의 해시 값을 미리 계산해둔 표입니다.
   * 솔트를 사용하면, 동일한 비밀번호라도 사용자마다 다른 해시 값을 갖게 되어, 레인보우 테이블 공격을 무력화시킬 수 있습니다.



### 궁금한 점?

1. Spring Filter, Interceptor

Filter는 HTTP 요청과 응답에 대한 전처리와 후처리를 수행하며, 스프링 시큐리티의 필터 체인은 여러 보안 관련 작업을 순차적으로 수행합니다.

* 일반적으로 로깅, 인증, 인코딩 설정 등에 사용됩니다.
* 필터는 디스패처 서블릿(Dispatcher Servlet)이 요청을 처리하기 전에 실행됩니다.

인터셉터는 주로 컨트롤러에 도달하기 전후의 요청을 처리합니다. 스프링 시큐리티와 함께 사용되면, 사용자의 권한에 따라 특정 로직을 실행하거나 접근을 제한하는 등의 역할을 수행할 수 있습니다.

인터셉터는 보안 컨텍스트(Security Context) 내에서 실행되어 현재 인증된 사용자의 정보에 접근할 수 있습니다.



요청과 응답 전체적인 순서 정리

1. **HTTP 요청 수신**: 클라이언트로부터 HTTP 요청이 들어옵니다.
2. **필터 실행**: 스프링의 필터 체인이 동작합니다. 이때 필터는 프론트 컨트롤러(디스패처 서블릿)에 도달하기 전에 요청을 처리합니다. 스프링 시큐리티 필터와 같은 보안 관련 필터들도 이 단계에서 실행됩니다.
3. **디스패처 서블릿(프론트 컨트롤러)**: 디스패처 서블릿이 요청을 받아 적절한 컨트롤러로 라우팅합니다.
4. **인터셉터 실행**: 디스패처 서블릿이 컨트롤러를 호출하기 전후로 인터셉터가 실행됩니다. 인터셉터는 컨트롤러의 실행 전, 실행 후, 그리고 뷰가 렌더링된 후에 추가적인 처리를 수행할 수 있습니다.
5. **컨트롤러 실행**: 실제 비즈니스 로직이 컨트롤러에서 실행됩니다.

<figure><img src="../.gitbook/assets/image (6).png" alt=""><figcaption></figcaption></figure>



1. **@RequestAttribute와 스프링 시큐리티**
   * `@RequestAttribute`를 사용하여 스프링 시큐리티에서 설정된 사용자 정보나 권한 정보 등을 컨트롤러에서 쉽게 접근할 수 있습니다.
   * 요청 처리 과정에서 필터나 인터셉터에서 생성되는 데이터를 컨트롤러에서 효율적으로 사용할 수 있게 도와줍니다. 주로 상태 정보, 사용자 정보, 인증 데이터 등이 이 방식으로 전달되고 사용됩니다.
2. **@ControllerAdvice, @RestControllerAdvice와 스프링 시큐리티**
   * 전역적인 예외 처리에 사용됩니다. 스프링 시큐리티와 관련된 예외(예: 접근 거부, 인증 실패 등)를 처리하기 위해 사용될 수 있습니다.
   * `@RestControllerAdvice`는 RESTful API에서 발생하는 보안 관련 예외를 JSON 형태로 반환하는 데 사용됩니다.

