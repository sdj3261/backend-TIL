# Layered Architecture

### 목차

* 관심사의 분리
* 응집도
* 결합도
* Layered Atchitecture
* Identifier
  * UUID(Universally unique identifier)
  * ULID(Universally Unique Lexicographically Sortable Identifier)
  * TSID(Time-Sorted Unique Identifier)

### 강의 정리

**관심사의 분리?** : 한번에 한 가지 일만 처리할 수 있도록 나누는 것 ➡️ 코드가 단위별로 하나의 관심사에 충실할 수 있도록 만드는 것

프론트엔드 특성상 유저 시나리오 변경에 따라 인터페이스나 로직 변경이 빈번함

관심사 분리 원칙 적용 ❌ : 전체 기능을 파악하기 위해 읽어야 할 코드가 많고 길어서 파악이 어려움, 수정시 전체 코드를 변경하게 될 수 있음

관심사 분리 원칙 적용 ⭕️ : 코드 파악을 위해 읽어야하는 코드 단위가 작음, 수정 시 해당 사항이 있는 일부분먼 수정하면 됨

관심사 분리 이거 어떻게 하는건데? 유저 인터페이스(View)와 비즈니스 로직(Business/Domain logic)으로 분리(어떤 수준까지 분리할지 각자 기준을 정하는 것이 중요)\
유저 인터페이스(view) : 사용자와 어플리케이션이 화면에서 상호작용하는 영역

비즈니스 로직(business/domain logic) : 현실 세계의 비즈니스 규칙\
➡️ API 호출 로직을 view 로직과 분리하는 것만으로 어느 정도 관심사 분리를 달성할 수 있음

**Layered Architecture**\
대표적인 레이어드 아키텍처인 4 계층(4 Layered) 아키텍처의 각 레이어를 정리하면 아래와 같다.

**프레젠테이션 레이어**\
인터페이스와 애플리케이션이 연결되는 곳이다.\
웹 통신 프레임워크, CLI 등 인터페이스, 입출력의 변환 등 외부와의 통신을 담당한다.\


**애플리케이션 레이어** \*\*\*\* 소프트웨어가 제공하는 주요 기능(비즈니스 로직)을 구현하는 코드가 모이는 곳이다. 로직을 오케스트레이션하고, 트랜잭션의 시작과 끝을 담당한다.\


**도메인 레이어**\
도메인과 관련된 객체들이 모이는 곳이다.\
도메인 모델(엔티티, 값 객체), 도메인 서비스 등 도메인 문제를 코드로 풀어내는 일을 담당한다.\
**인프라스트럭처 레이어**\


다른 레이어을 지탱하는 기술적 기반을 담은 객체들이 모이는 곳이다.\
DB와의 연결, ORM 객체, 메시지 큐 등 애플리케이션 외적인 인프라들과의 어댑터 역할을 담당한다.\
레이어드 아키텍처는 의존성의 방향이 다음처럼 흐른다.\


**프레젠테이션 레이어 -> 애플리케이션 레이어 -> 도메인 레이어 -> 인프라스트럭처 레이어**

즉 프레젠테이션 레이어에 있는 코드는 애플리케이션 레이어에 있는 코드에 의존해야 한다. 그 반대인 애플리케이션 레이어 코드가 프레젠테이션 레이어에 있는 코드에 의존하면 안된다.

이처럼 의존성의 흐름은 항상 프레젠테이션 레이어에서 인프라스트럭쳐 레이어로 흘러야한다.

**Layered Architecture의 단점**\
프로젝트 규모가 커질수록, 확장성이 떨어진다고 생각합니다. 레이어로 분리된 관심사 외에 다른 관심사가 발견된 경우, 패키지 분리 및 코드 배치가 난감한 경우가 발생합니다.\
복잡한 비즈니스 논리를 해결하고 성능적 이점을 얻기는 어렵습니다.\


Layered Architecture를 적용하면 좋은 경우\
위와 같은 단점들이 명확하지만, 그럼에도 불구하고 다음과 같은 경우에 적용하면 좋은 아키텍처임에는 분명하다고 생각합니다.

**Identifier(식별자)가 필요한 이유?**\
네트워크 상에서 서로 모르는 개체들을 식별하고 구별하기 위해서는 각각의 고유한 이름이 필요하다. 이 이름은 고유성(유일성)이 매우 중요하다. 같은 이름을 갖는 개체가 존재한다면 구별이 불가능해 지기 때문이다. 고유성을 완벽하게 보장하려면 중앙관리시스템이 있어서 일련번호를 부여해 주면 간단하지만 동시다발적이고 독립적으로 개발되고 있는 시스템들의 경우 중앙관리시스템은 불가능하다.\


DB의 ID 자동 식별 전략을 사용하게 되면 단일 시스템에서는 pk를 자동 생성 전략으로 해도 문제가 되지 않습니다.\
하지만, 대규모 분산 처리 시스템에서 자동 증가 전략으로 pk를 생성한다고 했을 때에는 중복된 키가 생성될 수 있습니다.\
여러 노드에서 동일한 시간에 데이터를 생성하게 되면, 각 노드가 독립적으로 기본 키를 생성하기 때문에 중복된 키를 생성할 수 있기 때문입니다\


1. UUID (Universally Unique Identifier) 장점: 표준화되어 있으며, 광범위하게 사용됨. 다양한 생성 방법이 있어 (예: 랜덤, 시간 기반, 이름 기반 등) 다양한 요구 사항에 적합. 충돌 확률이 매우 낮음. 단점: 시간 순서가 없어서 시간에 따른 정렬이 불가능. 길이가 비교적 긺 (36 문자).
2. ULID (Universally Unique Lexicographically Sortable Identifier) 장점: 사전 순서로 정렬될 때 생성 순서를 유지. UUID보다 짧은 길이 (26 문자). 충돌 확률이 낮음. 시간 기반 첫 부분 덕분에 시간별 정렬이 가능하면서 랜덤성도 유지. 단점: UUID만큼 널리 표준화되지 않았음. 시간 관련된 첫 부분이 동일한 경우가 발생할 수 있어, 충돌의 가능성이 아주 약간 높아질 수 있음 (그러나 여전히 매우 낮음).
3. TSID (Time Sorted Identifier) 장점: 시간에 따른 정렬이 기본. 애플리케이션의 요구 사항에 따라 맞춤형 구현이 가능. 단점: 특정한 표준이나 규칙이 없어서 구현이나 사용에 있어 일관성이 떨어질 수 있음. 공통점: 모든 방식이 고유한 식별자를 생성하는 데 사용됨. 충돌 확률이 낮아 데이터베이스나 시스템에서 객체를 고유하게 식별하는 데 유용. ULID만의 독특한 장점: 정렬 가능성과 랜덤성의 조화: ULID는 사전적 정렬 시 시간 순서대로 나열되면서도 충분한 랜덤성을 유지합니다. 이를 통해 데이터를 시간별로 정렬하면서도 고유한 식별자를 보장할 수 있습니다. 짧은 길이: UUID에 비해 짧은 길이를 가지면서도 고유성을 유지합니다. 이로 인해 저장 공간 및 전송 효율이 높아집니다. ULID는 시간 기반의 정렬 기능과 고유 식별의 장점을 동시에 가져와서, 로그 저장, 데이터베이스 레코드 등에서 유용하게 사용될 수 있습니다.

### 궁금한 점?

1.UUID,ULID,TSID 성능 비교 및 어떤 상황에서 써야하는지 정리하기

\=> [https://velog.io/@ssssujini99/%EA%B0%9C%EB%B0%9C-idPK-%EC%A7%81%EC%A0%91%ED%95%A0%EB%8B%B9-%EC%A0%84%EB%9E%B5-Random-UUID-TSID-%EA%B0%81%EA%B0%81-%EB%B9%84%EA%B5%90%EB%B6%84%EC%84%9D](https://velog.io/@ssssujini99/%EA%B0%9C%EB%B0%9C-idPK-%EC%A7%81%EC%A0%91%ED%95%A0%EB%8B%B9-%EC%A0%84%EB%9E%B5-Random-UUID-TSID-%EA%B0%81%EA%B0%81-%EB%B9%84%EA%B5%90%EB%B6%84%EC%84%9D)

