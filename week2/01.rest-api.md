# 01.REST API

### 목차

* API(Application Programming Interface) <br>
**API**는 소프트웨어 프로그램(애플리케이션) 내부에 존재하는 기능 및 규칙의 집합입니다. 
즉, API를 제공하는 애플리케이션과 다른 서드파티 소프트웨어 및 하드웨어 등의 것들 사이의 간단한 인터페이스 라고도 볼 수 있습니다. <br>
서로 다른 어플리케이션이 통신하는 방법을 API를 통해 정의합니다.



* 정보은닉(Information Hiding)과 캡슐화(Encapsulation)
  + 정보은닉 <br>
정보 은닉은 무언가 정보를 은닉하여 보안적인 효과 + 은닉되어 알필요가 없어 덜 알아도 되어 간편하게 사용할 수 있게 해주는 의미도 내포한다. <br>
ex) 우리가 자동차를 몰때 엔진이 어떻게 구동되어 바퀴가 굴러가는지 지식 필요없이 페달만 밟으면 자동차가 굴러간다.

이것이 자동차 원리 설계 정보를 은닉함으로서 경쟁사로부터 제품내부를 알지못하게 보안하는 효과도 있지만 소비자가 페달만 밟으면 작동하도록 단순화 한것도 포함한다.
  + 캡슐화 <br> 캡슐화는 변수나 메소드를 감싸서 안보이게 하는 정보 은닉의 일부이다. 
  이를 통해 외부로부터의 접근을 제한하여 의도치 않은 동작을 통한 값 변경을 방지한다.

  + 둘의 차이점? 캡슐화를 통해 정보 은닉을 가능하며 이외에도 디자인패턴(팩토리 패턴),업캐스팅을 통해 정보은닉이 가능하다.

* Architecture와 Architecture Style의 차이
  + Architecture<br>
  + Architecture Style
  
아키텍쳐는 시스템이나 소프트웨어의 고수준의 구조를 의미합니다.
주요 시스템 구성 요소, 이들 구성 요소 간의 관계, 그리고 이들 구성 요소가 상호 작용하는 방법을 설명합니다.

아키텍처 스타일은  아키텍처가 지켜야하는 제약조건들의 집합이다.
예를 들어, '레이어드 (Layered)', '이벤트 주도 (Event-Driven)', '마이크로서비스 (Microservices)', '파이프-필터 (Pipe-and-Filter)' 등의 아키텍처 스타일이 있습니다.
간단히 말해, 아키텍처는 '무엇'과 '어떻게'에 관한 것이며, 아키텍처 스타일은 그러한 아키텍처를 구축하기 위한 '방법론'이나 '패턴'을 의미합니다.

* REST(7가지 제약 조건 위주로 정리) <br>
로이필딩의 REST 아키텍쳐
  1️⃣ **Starting with the Null Style**

2️⃣ **Client-Server**

3️⃣ **Stateless**

4️⃣ **Cache**

5️⃣ **Uniform Interface → 핵심!**

1. “The **central feature** that distinguishes the REST architectural style from other network-based styles is its emphasis on a **uniform interface** between components”
2. “By applying the **software engineering principle of generality** to the component interface, the overall system architecture is **simplified** and the **visibility** of interactions is improved.”
3. “**Implementations** are **decoupled** from the services they provide, which encourages **independent evolvability**.”
4. “The **trade-off**, though, is that a uniform interface **degrades efficiency**, since information is transferred in a **standardized form** rather than one which is specific to an application's needs.”
5. “The REST interface is designed to be efficient for **large-grain hypermedia data transfer**, optimizing for the **common case of the Web**, but resulting in an interface that is not optimal for other forms of architectural interaction.”
6. **필딩 제약 조건**
  1. Four Interface Constraints

      <aside>
      <img src="/icons/arrow-right_gray.svg" alt="/icons/arrow-right_gray.svg" width="40px" /> Identification of Resources → URI 등으로 리소스를 식별할 수 있다.

      </aside>

      <aside>
      <img src="/icons/arrow-right_gray.svg" alt="/icons/arrow-right_gray.svg" width="40px" /> Manipulation of Resources through Representations → 표현으로 리소스를 조작한다.

      </aside>

      <aside>
      <img src="/icons/arrow-right_gray.svg" alt="/icons/arrow-right_gray.svg" width="40px" /> Self-descriptive Messages → 메시지는 자기서술적이기 때문에 여러 레이어에서 처리/변환 가능하다.

     > JSON 같은 범용 포맷을 작게 사용하면 어떻게 해석해야 하는지 알 수 없기 때문에 자기서술적이기 어렵다. 뒤에서 다룰 MIME 타입으로 설명한다면, application/json이 아니라 application/dns+json 같은 타입을 써야 한다.
     >

     > REST API를 이야기할 때 까다로운 부분 중 하나.
     >
      </aside>

      <aside>
      <img src="/icons/arrow-right_gray.svg" alt="/icons/arrow-right_gray.svg" width="40px" /> Hypermedia as the Engine of Application State → 줄여서 HATEOAS라고 부른다. REST API를 이야기할 때 까다로운 부분 중 하나.

      </aside>

  2. 아키텍처 요소(5.2)에서 리소스와 표현을 구분

      <aside>
      <img src="/icons/arrow-right_gray.svg" alt="/icons/arrow-right_gray.svg" width="40px" /> Resource → 추상. ⇒ 특정 시점의 스냅샷이 아니라, 모든 시간에 통용되는 엔티티 집합. 객체지향에서 말하는 Entity라고 생각하면 편하다. <객체지향의 사실과 오해>의 표현을 빌린다면, “앨리스”라는 리소스는 키가 커지던 작아지던 항상 “앨리스”다.

      </aside>

      <aside>
      <img src="/icons/arrow-right_gray.svg" alt="/icons/arrow-right_gray.svg" width="40px" /> Representation → Data + Metadata + Meta-metadata… ⇒ 사실상 HTTP 메시지라고 보면 됨. 예를 들어, 리소스를 어떻게 조작할 것인가는 HTTP Method로 표현하게 되고, 리소스를 무엇으로 조작할 것인가는 Content-Type과 Body로 표현하게 된다.

      </aside>

  3. URI 파트(6.2)에서 리소스에 대해 다시 강조

      <aside>
      <img src="/icons/arrow-right_gray.svg" alt="/icons/arrow-right_gray.svg" width="40px" /> “The resource is not the storage object. The resource is not a mechanism that the server uses to handle the storage object.”

      </aside>

      <aside>
      <img src="/icons/arrow-right_gray.svg" alt="/icons/arrow-right_gray.svg" width="40px" /> 리소스, 표현, 실제 데이터 등은 전부 구분된다.

      </aside>

  4. 아키텍처 데이터 뷰(5.3.3)에서 HATEOAS에 대해 언급.

      <aside>
      <img src="/icons/arrow-right_gray.svg" alt="/icons/arrow-right_gray.svg" width="40px" /> 마지막 문단의 첫 문장: “The model application is therefore an **engine** that moves from one state to the next by examining and **choosing** from among the alternative **state transitions** in the current set of **representations**.”

     > 이렇게 하려면 표현에 선택 가능한 상태 전환이 포함돼야 한다.
     >

     > 이게 바로 하이퍼미디어 링크.
     >
      </aside>

      <aside>
      <img src="/icons/arrow-right_gray.svg" alt="/icons/arrow-right_gray.svg" width="40px" /> 대부분은 효율 문제로 표현에 링크를 넣지 않고, 클라이언트 개발자가 API 문서를 활용해 처리한다. 표현에서 상태 전환을 선택하는 게 아니라, API 문서를 참조해서 상태 전환을 강제하는 것.

      </aside>

      <aside>
      <img src="/icons/arrow-right_gray.svg" alt="/icons/arrow-right_gray.svg" width="40px" /> [Richardson Maturity Model](https://martinfowler.com/articles/richardsonMaturityModel.html)

     > <RESTful Web API>의 공저자인 레오나르드 리처드슨은 Hypermedia Control(대표적인 게 바로 링크)을 강조.
     >

     > 성숙한 REST라면 표현에 하이퍼미디어 컨트롤(링크)이 포함되어야 한다.
     >
      </aside>


6️⃣ **Layered System**

7️⃣ **Code-On-Demand**
<br>
로이 필딩은 필딩 제약 조건을 지키지 않는 API를 REST API라고 부르는 것에 반대하지만 리처드슨 성숙도 모델의 레벨 2만 만족해도 REST API라고 부르면 된다.
***

### 궁금한 점?

1. API를 한마디로 표현하면? <br>
=> 서로 다른 어플리케이션의 통신을 위해 API를 통해 약속하는 것이다. 
2. String 자료형의 캡슐화 <br>
=> String 클래스의 내부 필드는 private 제어자로 선언되어 있어 직접적으로 문자열 값에 접근하여 변경할 수 없다.<br>
String 값은 불변의 데이터라고 불리는 이유는 바로 캡슐화 덕분이다. 
공개 메서드와 은닉 메서드를 구분하고 공개 메소드의 갯수를 최소화 시키는 이유가 구현 은닉을 위한 설계이며 자바에서 인터페이스 라는 것을 사용하는 이유다.
![img.png](img.png)
3. 그런 REST API로 괜찮은가? NAVER D2의 REST API에 대한 자세한 강의 <br>
=> https://www.youtube.com/watch?v=RP_f5dMoHFc