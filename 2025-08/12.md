# [DB] MySQL InnoDB 스토리지 엔진 아키텍처
신띵킹 2025. 8. 11. 21:57

InnoDB는 MySQL에서 거의 유일한 레코드 기반 잠금을 제공합니다. 따라서 높은 동시성 처리가 가능하고 성능이 뛰어납니다.

InnoDB의 모든 테이블은 프라머리키를 기준으로 클러스터링 되어 저장됩니다. 프라이머리의 키 순서대로 디스크에 저장되며 모든 세컨더리 인덱스는 레코드의 주소 대신 프라이머리키의 값을 논리주소로 사용합니다.

따라서 PK 클러스터링 레인지 스캔은 상당히빨리 처리되며 다른 인덱스에 비해 비중이 높게 설정되어있습니다. (실행계획)

InnoDB는 테이블을 PK 기준으로 한 번만 정렬 저장  
세컨더리 인덱스까지 데이터 포함하면 데이터 중복이 커지고,  
업데이트/삭제 시 유지 비용이 폭발하기 때문에  
PK만 저장 → PK 인덱스를 통해 데이터 가져오기 구조를 씀  
실제 데이터는 PK 인덱스에 있으므로,  
세컨더리 인덱스 검색 후 PK 인덱스를 한 번 더 검색해야 함 → 더블 루프업이 발생

---

## MVCC (Multi Version Concurrency Control)

레코드 레벨의 트랜잭션을 지원하는 DBMS가 제공하는데 MVCC의 가장 큰 목적은 잠금을 사용하지 않는 **일관된 읽기**입니다.

언두로그를 이용해 이 기능을 구현하며 하나의 레코드의 여러개의 버전이 동시에 관리됩니다.

### READ COMMITTED 수준에서의 Insert → Update 과정

1. Insert문이 실행되면 Innodb 버퍼 풀과 디스크에 데이터가 쓰인다.
2. Update 문장이 실행되면 Innodb 버퍼풀에 업데이트 값으로 바뀌고 언두로그에는 변경 전 값이 복사된다.
3. 디스크는 InnoDB 백그라운드 쓰레드에 의해 기록이 될 수도 있고 안 됐을 수도 있다.
4. 커밋 전 SELECT 동작  
   - READ_UNCOMMITTED: 버퍼풀 데이터 반환  
   - READ_COMMITTED 이상: 언두로그 데이터 반환

이러한 과정을 MVCC라고 하며, 하나의 레코드에 2개 이상의 버전이 유지되고 필요에 따라 데이터가 보여지게 됩니다.

---

## MVCC + 세컨더리 인덱스 + UPDATE 폭탄 → Undo Log 폭증

### 심각해지는 경우
1. 긴 트랜잭션 + 대량 UPDATE
   - 긴 SELECT 중 해당 범위 데이터를 UPDATE → 이전 버전 계속 유지
2. 대량 UPDATE + 세컨더리 인덱스 존재
   - PK + 보조 인덱스 모두 변경
   - 보조 인덱스 리프에도 버전 체인 + Undo Log 증가

---

커밋 → 영구 반영  
롤백 → 버퍼풀 복구 + 언두 삭제 (필요 트랜잭션 없을 시)

MVCC를 통해 잠금 없는 읽기 제공  
SERIALIZABLE이 아닌 경우, 잠금 대기 없이 실행 가능

**Undo Tablespace 폭증 시** → 디스크 I/O 부하 + history list length 폭발 → 성능 저하 + 디스크 Full

대량 UPDATE → 트랜잭션 분할 / TRUNCATE + INSERT 권장

---

## MVCC + SERIALIZABLE 차이

- REPEATABLE READ / READ COMMITTED: SELECT는 MVCC 읽기 → 락 없이 가능
- SERIALIZABLE: SELECT도 락 필요 → UPDATE 중이면 SELECT 대기

| Lock Type | 동작 |
|-----------|------|
| S-LOCK    | 다른 트랜잭션이 SELECT 가능 |
| X-LOCK    | 다른 트랜잭션이 읽기/쓰기 불가 |

---

## Replica 활용
- 실시간 서비스 DB: READ 전용
- UPDATE: Replica 또는 저부하 시간대

---

## 데드락 감지
- 잠금 대기 목록을 그래프로 관리 → 교착 상태 트랜잭션 강제 종료
- 언두로그 적은 레코드 우선 종료 → 오버헤드 감소
- `innodb_deadlock_detect` ON/OFF 가능 (동시 처리 스레드 많으면 OFF + lock_wait_timeout)

---

## 장애 복구
- 시작 시 미완료 트랜잭션/페이지 복구
- `innodb_force_recovery` 단계별 설정 (1~6)
- 6단계까지 불가 → mysqldump로 백업 후 재생성
- 바이너리 로그로 최대한 복구

---

## 버퍼풀(Buffer Pool)
- 디스크 데이터/인덱스를 캐싱 + 쓰기 지연 → 랜덤 디스크 I/O 감소
- UPDATE/INSERT/DELETE 시 Dirty Page로 마킹 후 일괄 Flush
- SELECT 시 더티마킹 없음 (Hit 시 메모리에서 즉시 반환)

### 동작 흐름
1. 페이지 로딩 (디스크 → 버퍼풀)
2. 버퍼풀에서 변경
3. Dirty Page 마킹
4. Redo Log 기록 (WAL)
5. Flush 시점에 디스크 반영

---

## 버퍼풀 구조
- LRU (MRU + LRU)
- Free List
- Flush List

자주 접근 데이터 → Adaptive Hash Index 추가 (B+Tree 탐색 없이 O(1) 접근)

---

## 성능 최적화
- 버퍼풀 메모리 증설 → 조회 성능 향상
- Redo Log 이해 필요 (Dirty Page 손실 대비)
- `innodb_max_dirty_pages_pct` 값 조정으로 Flush 전략 제어
