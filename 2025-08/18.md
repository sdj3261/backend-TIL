# InnoDB 트랜잭션 & 잠금 — 실전 요약 (2025-08-18)

> 핵심
> - InnoDB의 “행 잠금”은 **행 자체가 아니라 _인덱스 키_**에 건다.
> - **정확한 인덱스**를 태우면 **잠금 범위 최소화** → 동시성↑, 대기/교착↓.
> - 팬텀이 안 보이는 이유는 두 가지: **MVCC(스냅샷 읽기)** 또는 **갭/넥스트-키 락(락킹 읽기)**.

---

## 1) 읽기 방식과 팬텀의 관계

### 스냅샷 읽기 (락 없음)
- 대상: 일반 `SELECT`
- 원리: 트랜잭션 시작(또는 첫 SELECT) 시점의 **스냅샷**을 본다.
- 효과: 중간 INSERT/UPDATE가 **보이지 않음** → 팬텀 체감 **없음**.

```sql
-- RR 기준 예시
START TRANSACTION;
SELECT COUNT(*) FROM users WHERE age BETWEEN 20 AND 29;  -- 예: 10

-- 다른 세션에서 INSERT COMMIT

SELECT COUNT(*) FROM users WHERE age BETWEEN 20 AND 29;  -- 여전히 10 (MVCC 스냅샷)
COMMIT;
```

### 락킹 읽기 (잠금 발생)
- 대상: `SELECT ... FOR UPDATE/SHARE`, `UPDATE`, `DELETE`
- 원리: **레코드락 + 갭락(= 넥스트-키 락)**으로 **범위 & 삽입** 제어
- 효과: 같은 범위로의 **INSERT 차단** → 팬텀 **방지**

```sql
START TRANSACTION;
SELECT id FROM users WHERE age BETWEEN 20 AND 29 FOR UPDATE;  -- 범위에 넥스트-키 락
-- 다른 세션의 INSERT(age=25)는 현재 트랜잭션 COMMIT 전까지 대기/블록
```

---

## 2) InnoDB 잠금 종류 (요지)

- **레코드 락 (Record Lock)**: 인덱스의 **특정 키 엔트리**에 S/X 잠금
- **갭 락 (Gap Lock)**: 키와 키 사이 **구간** 잠금(삽입 차단)
- **넥스트-키 락 (Next-Key)**: 레코드락 + 양측 갭락(범위 보호)
- **인텐션 락 (IS/IX)**: 행락과 테이블락의 **충돌 판정용 신호**
- **인서트 인텐션 락**: 삽입 경쟁 시 **동시 진행**을 가능하게 조율
- **AUTO-INC 락**: AUTO_INCREMENT 할당 동시성 제어(모드 0/1/2)

> **중요**: InnoDB의 “행 잠금” 단위는 **인덱스 키**. **어떤 인덱스를 타느냐**가 **잠금 범위**를 결정한다.

---

## 3) 격리 수준 요약

| 수준 | 특징 | 팬텀 | 비고 |
|---|---|---|---|
| READ UNCOMMITTED | 커밋 전 읽기 허용 | 발생 | 거의 사용 X |
| **READ COMMITTED** | 커밋된 것만 읽음, 갭락 **대폭 감소** | **발생 가능** | 동시성↑, UPDATE 시 **조건 재검증** 필요 |
| **REPEATABLE READ** (기본) | 같은 트랜잭션 내 반복 읽기 일관 | **락킹 읽기에서 방지** | 넥스트-키로 삽입 차단(범위 넓어질 수 있음) |
| SERIALIZABLE | 가장 보수적 | 없음 | 동시성↓ |

---

## 4) 잠금 범위 최소화 전략

### A. 인덱스 설계
- **유니크 + 동등(=) 조건** → 넥스트-키가 **레코드락**으로 축소
```sql
CREATE UNIQUE INDEX ux_users_email ON users(email);
SELECT * FROM users WHERE email=? FOR UPDATE;  -- 해당 1건만 잠금
```
- **복합 인덱스 순서**: `= 조건들 → 범위 조건 → 정렬 컬럼`
```sql
CREATE INDEX ix_issue (coupon_id, is_used, valid_start, valid_end, id);
```
- **FK/조인/정렬 컬럼**에도 인덱스
- **파티셔닝**(시간/테넌트 등)으로 검색 범위 자체를 분할

### B. 쿼리 작성
- 컬럼에 함수/연산 적용 금지
  - 나쁨: `WHERE DATE(created_at)='2025-08-18'`
  - 좋음: `WHERE created_at >= '2025-08-18' AND created_at < '2025-08-19'`
- **OR 분해**: `UNION ALL`로 나눠 각 조건에 맞는 인덱스를 타게
- 옵티마이저가 엉뚱한 인덱스를 고르면 `FORCE INDEX`

### C. 트랜잭션 운영
- **짧게 잠그고 빨리 커밋**: PK 순서, 작은 배치 + 빈번 커밋
- **일관된 잠금 순서**: 교착 위험 감소
- **READ COMMITTED + 필요한 지점만 락킹**(팬텀 감내 가능 시)
- **SKIP LOCKED / NOWAIT**(8.0+): 대기 회피

---

## 5) “업데이트 대상만” 잠그는 2단계 패턴

> 선정(좁은 범위에서 1건 잠금) → PK 기반 갱신(레코드락만)

```sql
-- 1) 후보 선점: 인덱스 설계 전제, 대기 회피
SELECT id
FROM issued_coupons FORCE INDEX(ix_issue)
WHERE coupon_id=? AND is_used=0
  AND valid_start<=NOW() AND valid_end>NOW()
ORDER BY id
LIMIT 1
FOR UPDATE SKIP LOCKED;

-- 2) PK로 갱신 + 낙관적 가드(조건 재확인)
UPDATE issued_coupons
SET is_used=1, used_at=NOW()
WHERE id=? AND is_used=0;
```

- RC 환경에선 팬텀 가능 → **UPDATE에 조건 재검증**(또는 **version 칼럼**) 필수

---

## 6) EXPLAIN로 인덱스/범위 확인

```sql
EXPLAIN FORMAT=TREE SELECT ...;
EXPLAIN ANALYZE SELECT ...;     -- 실제 스캔/시간/행수
```
- `type=const/eq_ref/ref` → 좋음(= 중심)
- `type=range` → 범위 스캔(락 범위가 넓어질 수 있음)
- `type=index/ALL` → 인덱스/테이블 풀스캔(주의)

세션 스캔 경향:
```sql
SHOW SESSION STATUS LIKE 'Handler_read%';
-- Handler_read_key(키 탐색), Handler_read_next(순차 스캔), Handler_read_rnd_next(풀스캔) 등
```

---

## 7) 데드락/대기 모니터링

```sql
-- 교착 분석
SHOW ENGINE INNODB STATUS\G;

-- 현재 잠금
SELECT * FROM performance_schema.data_locks;

-- 메타데이터 락(DDL 대기) 확인
SELECT * FROM performance_schema.metadata_locks;
```

---

## 9) 요약

- InnoDB의 잠금 단위는 **인덱스 키**.
- **정확한 인덱스 설계**가 곧 **잠금 범위 최소화**다.
- **Repeatable Read**: 넥스트-키로 안전하지만 범위가 넓어질 수 있음.
- **RC**: 동시성↑(갭락↓) 대신 UPDATE 시 **조건 재검증** 필요.
- 작업 큐/선정 로직은 **2단계 패턴 + SKIP LOCKED**가 정석.
