# Today I Learned (2025-08-09)

이 저장소는 제가 매일 학습한 내용을 기록하고 정리하기 위해 만든 공간입니다.

---

## 📚 공부한 내용

**[개발] 쿠폰 프로젝트 MSA 전환 (1) - Spring Cloud Gateway 적용기**

### **1. 기존 구조와 전환 필요성**
- **기존**: 모놀리틱 구조에서 인증, 쿠폰, 기타 서비스 로직이 하나의 패키지에 혼재
- **문제점**:
  - 인증 로직이 서비스 곳곳에 중복
  - 도메인 간 강한 연관관계
- **전환 목표**:
  - 모듈 간 **관심사 분리**
  - 인증·로깅 등 **횡단 관심사**를 Gateway에서 통합 처리
  - 서비스 간 통신은 **REST API** 기반으로 변경

---

### **2. 모듈 분리**
- `api-gateway` : 인증, 로깅 등 공통 로직 처리
- `coupon-service` : 쿠폰 관련 API
- `other-service` : 기타 서비스 API
- **공통 코드 분리 원칙**:
  - 인증·로깅 → `api-gateway`
  - DTO, ErrorCode, 예외 처리 → 각 서비스 도메인에 맞게 최소한만 포함

---

### **3. Gateway 설정**
```yaml
server:
  port: 8080

spring:
  data:
    redis:
      host: localhost
      port: 6379
      timeout: 5000
  cloud:
    gateway:
      routes:
        - id: coupon-service
          uri: http://localhost:8081
          predicates:
            - Path=/coupons/**
          filters:
            - StripPrefix=1
        - id: other-service
          uri: http://localhost:8082
          predicates:
            - Path=/others/**
          filters:
            - StripPrefix=1
```
- **id** : 라우팅 식별자 (서비스명)
- **uri** : 요청을 전달할 서비스 주소
- **predicates** : 경로 매칭 조건
- **filters** : 요청 경로 전처리 (`StripPrefix=1`)

---

### **4. Netty 기반의 동작 방식**
- **톰캣**: 요청마다 쓰레드 1개를 점유 → Blocking I/O → 요청 수 증가 시 쓰레드 폭증 및 컨텍스트 스위칭 오버헤드
- **Netty**:
  - **EventLoop 기반 Non-blocking I/O**
  - Channel을 EventLoop에 할당, I/O 이벤트를 큐잉
  - 하나의 EventLoop가 여러 채널을 처리
  - 쓰레드 점유 시간을 최소화하여 높은 RPS 처리에 유리

---

### **5. 인증 필터 구현 (AuthGatewayFilter.java)**
```java
@Component
@RequiredArgsConstructor
public class AuthGatewayFilter implements GlobalFilter, Ordered {
    private final StringRedisTemplate redisTemplate;
    private final ObjectMapper objectMapper;

    @Override
    public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {
        String authHeader = exchange.getRequest().getHeaders().getFirst(HttpHeaders.AUTHORIZATION);

        if (authHeader == null || !authHeader.startsWith("Bearer ")) {
            return onUnauthorized(exchange, "토큰이 없습니다.");
        }

        String sessionId = authHeader.substring(7);
        String redisKey = "SESSION:" + sessionId;

        return Mono.fromCallable(() -> redisTemplate.opsForValue().get(redisKey))
                .flatMap(sessionJson -> {
                    if (sessionJson == null) {
                        return onUnauthorized(exchange, "세션이 없습니다.");
                    }
                    try {
                        UserSessionDto session = objectMapper.readValue(sessionJson, UserSessionDto.class);
                        ServerHttpRequest mutated = exchange.getRequest().mutate()
                                .header("X-USER-ID", String.valueOf(session.id()))
                                .header("X-USER-EMAIL", session.email())
                                .header("X-USER-ROLE", session.roles().get(0))
                                .build();
                        return chain.filter(exchange.mutate().request(mutated).build());
                    } catch (Exception e) {
                        return onUnauthorized(exchange, "세션 파싱 실패");
                    }
                })
                .switchIfEmpty(onUnauthorized(exchange, "인증 실패"));
    }

    private Mono<Void> onUnauthorized(ServerWebExchange exchange, String message) {
        exchange.getResponse().setStatusCode(HttpStatus.UNAUTHORIZED);
        exchange.getResponse().getHeaders().setContentType(MediaType.APPLICATION_JSON);
        String body = "{\"error\":\"" + message + "\"}";
        DataBuffer buffer = exchange.getResponse().bufferFactory().wrap(body.getBytes(StandardCharsets.UTF_8));
        return exchange.getResponse().writeWith(Mono.just(buffer));
    }

    @Override
    public int getOrder() {
        return -1; // 가장 먼저 실행
    }
}
```
- **Redis 기반 세션 검증**
- 인증 성공 시 유저 정보를 HTTP 헤더에 실어 downstream 서비스로 전달
- 인증 실패 시 `401 Unauthorized` 반환

---

### **6. 정리**
- **Spring Cloud Gateway**:
  - 비동기 논블로킹 I/O → 고성능 API 중계
  - 횡단 관심사 분리에 최적
  - 서비스 추상화로 클라이언트-서비스 간 결합도 감소
- **전환 효과**:
  - 코드 중복 제거
  - 서비스 독립성 확보
  - 확장·장애 대응력 향상

---

## 🔗 참고
- [Spring Cloud Gateway Docs](https://spring.io/projects/spring-cloud-gateway)
- [Netty Docs](https://netty.io/wiki/user-guide-for-4.x.html)
