# Today I Learned (2025-08-05)

이 저장소는 제가 매일 학습한 내용을 기록하고 정리하기 위해 만든 공간입니다.

---

## 📚 공부한 내용

**[DB] MySQL 아키텍처와 쓰레드·메모리 구조 및 쿼리 실행 흐름**

### **MySQL 아키텍처**
- **MySQL 엔진**: 클라이언트 접속, SQL 파싱·전처리, 옵티마이저 → **쿼리 처리의 두뇌**
- **스토리지 엔진**: 실제 데이터를 디스크에 저장·읽기 처리 → InnoDB, MyISAM, MEMORY 등 **테이블 단위로 선택 가능**
- **핸들러 API**: MySQL 엔진과 스토리지 엔진 간 인터페이스  
  → `SHOW GLOBAL STATUS LIKE '%Handler%'` 로 작업량 확인 가능
- **장점**: 스토리지 엔진 교체 가능(트랜잭션용 InnoDB, 읽기 최적 MyISAM, 초고속 MEMORY 등)
- **단점**: 엔진 간 일관성 부족, 같은 SQL이라도 실행계획 차이 발생 가능

### **쓰레드 구조**
- **포그라운드 쓰레드**: 클라이언트 연결마다 1:1 대응, 쿼리 처리 후 캐시로 반환 (`thread_cache_size`)
- **백그라운드 쓰레드**:
  - InnoDB: 로그 쓰기, 버퍼풀 플러시, 인서트 버퍼 병합, 잠금 모니터링 등
  - **쓰기 작업은 백그라운드 비동기 처리 → 성능 최적화**
- **엔터프라이즈 쓰레드 풀**: 쓰레드 개수 제한으로 CPU 자원 낭비 방지, `thread_pool_stall_limit`, `thread_pool_max_threads` 로 제어

### **메모리 구조**
- **글로벌 메모리**: 서버 시작 시 OS로부터 할당, 모든 쓰레드 공유 (예: InnoDB 버퍼 풀)
- **로컬 메모리**: 커넥션·쿼리 실행 시 독립 할당, 세션 종료 시 해제 (예: 소트 버퍼, 조인 버퍼)
- **버퍼풀**: InnoDB에서 자주 접근하는 데이터를 캐싱해 I/O 최소화

### **쿼리 실행 흐름**
1. **SQL 파서**: 토큰화·트리화 → 문법 오류 검출
2. **전처리기**: 테이블·컬럼·권한 검증
3. **옵티마이저**: 최적 실행 계획 생성 (DBMS의 두뇌)
4. **실행 엔진**: 실행 계획을 핸들러에게 전달
5. **스토리지 엔진**: 디스크 읽기/쓰기 처리

### **InnoDB가 많이 쓰이는 이유**
- **트랜잭션 & ACID 보장**: Commit/Rollback, Crash Recovery
- **동시성 제어**: **MVCC** & **Row-level Lock** → 읽기·쓰기 충돌 완화
- **데이터 안정성**: redo/undo 로그, 외래키 지원
- **성능 최적화**: 버퍼 풀 기반 I/O 최적화

> **단점**: redo/undo 로그 기록으로 인한 쓰기 성능 저하, 대규모 업데이트 시 디스크 I/O 증가, 버퍼 풀 메모리 사용량 큼

### **MySQL 8.0의 변화**
- **테이블 딕셔너리 InnoDB 통합**: 메타데이터 트랜잭션 관리 가능 (Atomic 저장·롤백)
- **쿼리 캐시 제거**: 데이터 변경 시 무효화 문제 → 성능·버그 이슈로 완전 제거
- **컴포넌트 아키텍처**: 플러그인 간 통신 불가 문제 해결, 안전한 서버 내부 호출 지원

---

## **실무 인사이트**
- **버퍼풀·로그 쓰레드 성능**이 InnoDB 병목의 핵심 → 디스크 I/O 최적화 중요
- **스토리지 엔진별 특성 고려**: 트랜잭션 처리(InnoDB), 빠른 읽기(MyISAM), 메모리 기반 처리(MEMORY)
- **엔터프라이즈 쓰레드 풀 활용**: 컨텍스트 스위칭 최소화 → 고부하에서도 성능 안정화

---

[DB] MySQL 아키텍처와 쓰레드·메모리·쿼리 실행 구조

MySQL 철학과 구조 (Real MySQL 관점)

핸들러 API 기반 모듈형 아키텍처: 스토리지 엔진 교체 가능 (InnoDB, MyISAM 등)

가벼운 엔진 설계: 리소스 제약 환경에서도 동작 가능

스토리지 엔진 분리: SQL 파싱·전처리·옵티마이저는 MySQL 엔진, I/O는 스토리지 엔진 담당

오라클과의 차이

오라클은 단일 엔진 일체형, MySQL은 플러그인형 스토리지 엔진

오라클은 강한 ACID & 일관성, MySQL은 유연성과 성능 중심

InnoDB 핵심

버퍼 풀 → 디스크 Write-back 아키텍처

Redo/Undo 로그: 트랜잭션 안정성 보장, 하지만 쓰기 I/O 부하 발생

MVCC·Row-level Lock: 동시성 제어 최적화

디스크 I/O 병목

트랜잭션 커밋 시 Redo 로그 동기 기록 → 트랜잭션 처리량 직결

Buffer Pool의 더티 페이지 Flush 시 디스크 I/O 폭증 → 성능 저하 가능

튜닝 포인트: redo 로그 크기, I/O 쓰레드 개수, Buffer Pool 최적화

## 🔗 참고
- [MySQL 8.0 Architecture](https://dev.mysql.com/doc/refman/8.0/en/innodb-architecture.html)
- [InnoDB Buffer Pool](https://dev.mysql.com/doc/refman/8.0/en/innodb-buffer-pool.html)
