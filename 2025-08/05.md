[DB] MySQL 아키텍처와 쓰레드, 메모리 구조, 쿼리 실행 구조
신띵킹 2025. 8. 5. 22:52 
MySQL 서버는 MySQL 엔진과 스토리지 엔진으로 구분할 수 있습니다.

또한 스토리지 엔진은 핸들러 API를 만족하면 누구든 스토리지 엔진을 구현해서 MySQL 서버에 추가해서 사용할 수 있습니다.

가볍고 확정성이 오라클에 비해 뛰어납니다.

 

기본으로 제공되는 엔진은 InnoDB 스토리지 엔진과 MyISAM 스토리지 엔진이 있습니다.

 

이러한 스토리지 엔진이 나뉘어져있는 구조는 다른 DBMS에서는 가질 수 없는 엄청난 혜택이 있으며 반대로 문제되는 점들도 존재한다. 

 

MySQL의 장점은 커뮤니티 에디션이 무료인것 뿐만 아니라 필요 시 테아블 수준에서 InnoDB → MyISAM(읽기 빠른 엔진)으로 전환하거나, 커스텀 스토리지 엔진 개발 가능하다. (메모리 기반, 등..)

 

즉, 동일한 SQL 처리 레이어에서 다른 특성을 가진 엔진(InnoDB, MyISAM, Memory, NDB 등)을 끼워 넣어 사용할 수 있음.
다른 DBMS에는 없는 독특한 구조 → 확장성 & 유연성 강력하고 이를 통해 트랜잭션이 필요한 경우는 InnoDB, 읽기 위주는 MyISAM, 초고속 메모리 기반 처리 MEMORY 엔진, 분산 NDB Cluster 
단점은

1. 스토리지 엔진간 일관성이 부족 합니다. (스토리지 엔진마다 트랜잭션, 락, 인덱스, 외래키 지원이 다름)

2. 튜닝 난이도가 어렵습니다. 같은 SQL이라도 엔진에 따라 실행계획이 달라질 수 있습니다.

 

 


 

차례대로 살펴보면 MySQL엔진은 클라이언트로부터의 접속 및 쿼리 요청을 처리하는 커넥션 핸들러와 SQL 파서 및 전처리기, 옵티마이저가 중심이다. 표준 SQL 문법을 지원하여 ANSI 쿼리는 타 DBMS와 호환되어 실행될 수 있다.

 

MySQL 엔진이 SQL 문장 최적화 및 분석하는 두뇌라면 스토리지 엔진은 실제 데이터를 디스크 스토리지에 저장하거나 데이터를 읽는다. 

 

CREATE TABLE test_table (1, 2 , 3) ENGINE=innodb
 

위 테이블은 INNODB 스토리지 엔진을 사용하도록 정의한 것이다. 이제 테이블에 쿼리가 발생되면 InnoDB 엔진이 처리를 담당한다. 각 스토리지 엔진은 성능향상을 위해 키 캐시나 버퍼 풀 기능을 내장한다. (InnoDB는 버퍼 풀 방식)

 

다음은 핸들러 API 이다. 

핸들러 api를 통해 MySQL 스토리지 엔진에 쓰기나 읽기 요청을 하는데 이 때 아래 쿼리로 얼마나 많은 데이터 작업이 있었는지 확인 할 수 있다.

 

SHOW GLOBAL STATUS LIKE '%Handler%'
 

MySQL은 아래와 같은 쓰레드 모델을 가지는데 프로세스 기반이 아닌 쓰레드 수준에서 작동한다. 

크게 포그라운드 쓰레드와 백그라운드 쓰레드를 볼 수 있으며 performance_schema.threads에서 실행중인 쓰레드 목록을 볼 수 있다.

 


 

백그라운드 쓰레드가 숫자가 더많으며 (왜 더많을까?) 이는 설정이 가능하다. 

포그라운드 쓰레드는 MySQL 서버에 접속된 클라이언트 수만큼 존재하며 커넥션 연결 및 쿼리 문장을 처리한다. 종료 후 쓰레드 캐시로 되돌아간다. 이미 일정 개수의 포그라운드 쓰레드가 차 있으면 종료 시킨다. (thread_cache_size) 설정

 

포그라운드 쓰레드는 데이터를 MySQL의 버퍼나 캐시로부터 가져오며 없는 경우엔 디스크 데이터를 직접 읽어 처리한다. MyISAM은 디스크 쓰기 작업까지 포그라운드 쓰레드가 담당하지만 InooDB 테이블은 데이터 버퍼나 캐시까지만 포그라운드 쓰레드가 처리하고 나머지 버퍼로부터 디스크까지 기록하는건 백그라운드 쓰레드가 처리한다.

 

MyISAM은 그래서 해당이 안되지만 InnoDB에서는 인서트 버퍼 병합, 로그 -> 디스크, 버퍼풀을 디스크에 기록, 데이터를 버퍼로 읽기, 잠금 데드락 모니터링은 모두 백그라운드 쓰레드에서 관리된다.

 

가장 중요한건 로그 쓰레드와 버퍼를 디스크로 내리는 쓰레드인데 5.5버전 부터 2개 이상 지정가능하여 설정 가능하다.

읽기쓰레드는 클라이언트 쓰레드에서 처리되어 많이 설정할 필요 없지만 쓰기 쓰레드는 백그라운드로 아주 많은 작업을 처리 하기 때문에 내장 디스크는 2~4 DAS/SAN은 디스크 최적 수치만큼 올리는게 좋다.

 

왜 로그 쓰레드 & 버퍼 플러시 쓰레드가 중요한가?
InnoDB의 성능 병목 지점이기 때문이다. 디스크 I/O
InnoDB는 버퍼 풀(Buffer Pool) 에 데이터를 먼저 기록하고,
나중에 백그라운드에서 디스크에 반영하는 구조(Write-back)입니다.

이 과정에서 로그 쓰기(redo log), 버퍼 플러시(flush) 가 디스크 I/O와 맞물려 병목이 됩니다.

특히 트랜잭션 커밋 시점에는 redo log에 동기 기록이 필요하므로 로그 쓰레드 성능이 직접적으로 트랜잭션 처리량에 영향을 줍니다.

즉, 로그 쓰기/버퍼 플러시 속도가 느리면 전체 쿼리 처리 속도가 느려짐.
 

데이터의 읽기 작업은 절대 지연될 수 없지만 쓰기 작업은 버퍼링되어 처리될 수 있기 때문에 InnoDB도 동일한 방식으로 처리한다.

MyISAM은 쓰기 작업까지 포그라운드쓰레드가 처리하기 때문에 디스크가 저장될때까지 기다려야한다.

 


다음은 MySQL에서 사용되는 메모리 공간이다.

크게 글로벌 메모리와 로컬 메모리 영역으로 구분할 수 있으며 글로벌 메모리 공간은 서버 시작부터 OS로부터 할당된다.

 

글로벌 메모리 영역은 클라이언트 수와 무관하게 할당되며 글로벌 영역이 N개여도 모든 쓰레드에 의해 공유된다.

 

로컬 메모리 영역은 클라이언트 수만큼 독립적으로 할당되며 절대 공유되지 않는다. (세션 메모리 영역)

일반적으로 글로벌 메모리 영역의 크기는 주의해서 설정하지만 로컬 메모리 영역은 크게 신경쓰지 않지만 최악의 경우 메모리 부족으로 멈출 수 있어 적절한 메모리 공간을 설정해야한다. 또한 쿼리의 용도별로 필요할 때만 공간 할당되고 필요하지 않을 땐 할당조차 하지 않을 수 있다.

 

커넥션이 열려있는 동안 계속 할당(커넥션버퍼, 결과 버퍼)

쿼리 실행 순간만 할당 및 해제 (소트 버퍼, 조인 버퍼)

 

쿼리 실행 순서
쿼리 SQL 파서 -> SQL 옵티마이저 -> SQL 실행기 -> 데이터 읽기/쓰기 -> 디스크 순으로 작동하며

데이터 읽기/쓰기 작업만 스토리지 엔진에 의해 처리되고 나머진 MySQL엔진에 의해 처리된다. 

서버에 포함되지 않은 스토리지 엔진을 사용하려면 서버를 다시 빌드해야한다. 

 

SHOW Plugins로 플러그인들을 확인 할 수 있으며 MySQL만의 독특한 모델로 여러 플러그인을 설치하고 교체할 수 있다.

인증, 쿼리 재작성, 전문 검색 파서 등이 존재하고 커스텀 확장이 가능하다.

 

MySQL 8.0 부터는 플러그인 아키텍처를 대체하기 위해 컴포넌트 아키텍쳐가 지원된다. 플러그인끼리 통신이 불가능하다는 단점을 극복하고 MySQL 서버나 변수 함수를 직접 호출해 안전하지 않았다.

 

쿼리 실행 구조
1. 쿼리 파서는 쿼리문장을 토큰으로 분리해 트리 형태로 만들어 냅니다. 이 때 문법 오류가 발견되고 오류 메세지를 전달합니다.

2. 전처리기는 파서 트리를 기반으로 쿼리 문장에 구조적 문제가 있는지 확인하고 테이블 이름, 컬럼 이름, 내장 함수를 매핑하여 접근 권한 여러가지를 확인합니다. (실재 존재 유무 판단, 권한 판단)

3. 옵티마이저는 쿼리 문장을 저렴한 비용으로 가장 빠르게 처리할지를 결정하는데 DBMS의 두뇌를 담당합니다. 옵티마이저가 더 나은 선택을 하게 유도하는게 중요하며 옵티마이저의 역할을 매우 넓습니다.

4. 실행엔진은 핸들러(스토리지 엔진)에게 요청하는 역할을 하며 만들어진 계획대로 핸들러에게 요청 및 결과를 다른 핸들러에게 넘깁니다.

5. 핸들러(스토리지 엔진)는 실행 엔진의 요청에 따라 데이터를 디스크로 저장하고 읽어오는 역할을 하며 MyISAM 테이블이냐 InnoDB 테이블이냐에 따라 핸들러 엔진을 다르게 결정합니다. 

 


 

쿼리 캐시는 MySQL 서버에서 빠른 응답을 필요로 할때 자주사용되는 실행 결과를 메모리에 캐시해 매우 빠른 성능을 보였지만 데이터가 변경되면 관련 캐시가 모두 무효화처리되어야 하기 때문에 심각한 성능 유발했고 버그의 원인이되어 완전히 제거되었다.

 

또한 엔터프라이즈 에디션은 쓰레드 풀 기능이 있어 사용자의 요청을 처리하는 쓰레드 개수를 줄여 동시 처리 요청이 많더라도 MySQL 서버의 CPU가 제한된 개수의 쓰레드 처리 에만 집중할 수 있게 해서 서버의 자원 소모를 줄이는 것이 목적이다.

많이 증대시켜서 동시요청수를 증대 시키는게 아닌 컨텍스트 스위칭·락 경쟁이 줄여, 고부하 상황에서도 일관된 성능을 유지하는 것이 핵심이다.

 

모든 쓰레드가 일하고 있다면 새로운 작업 쓰레드를 추가할지 기다릴지 여부를 판단하고 이는 thread_pool_stall_limit과 thread_pool_max_threads로 설정된 개수만큼과 시간으로 관리하게한다.

 

테이블 구조정보와 메타데이터 테이블 딕셔너리는 5.7버전까지 파일로 저장했지만 생성 및 변경이 트랜잭션을 지원하지 않아 중간에 꺼지면 일관되지 않은 상태로 남는 문제가 있어 테이블이 깨지는 문제가 있었다.

 

8.0버전 부터 이를 해결하기 위해 모두 InnoDB 테이블에 관리하여 트랜잭션으로 관리된다. 대표적으로 사용자 인증 권한 테이블이 있으며 mysql.ibd라는 테이블스페이스에 저장된다. 따라서 Atomic 하게 저장또는 롤백되며 테이블이 깨질 문제가 없다.

 

다음에는 스토리지 엔진을 자세하게 살펴보려고 합니다.

 

왜 InnoDB가 많이 쓰일까?
트랜잭션 지원
ACID 보장 (Atomicity, Consistency, Isolation, Durability)
Commit/Rollback
동시성 제어
MVCC (Multi-Version Concurrency Control) 제공 → 읽기/쓰기 충돌 완화
Row-level Locking (행 단위 잠금) → MyISAM처럼 테이블 전체 잠금 안 걸림
데이터 안정성
Crash recovery: redo/undo 로그로 장애 시 복구
Foreign Key 제약조건 지원
성능
버퍼 풀 (Buffer Pool): 자주 접근하는 데이터를 메모리에 캐싱 → 빠른 I/O
그렇다면 단점은 무엇일까요?

redo/undo로그에 항상 쓰기 때문에 안정성을 보장하지만 이 과정이 쓰기 성능이 느려지고 특히 대규모 업데이트나 인덱스 랜덤 I/O 엑세스 시 쓰기 성능이 느려질 수 있습니다.

또한 InnoDB Buffer Pool이 데이터를 메모리에 캐싱하기 때문에 메모리를 많이 먹고 버퍼풀을 너무 작게 잡으면 디스크 I/O가 급증합니다

 

 

 

 

또한 단순조회 시에도 트랜잭션이 걸려 다른 트랜잭션이 중간에 변경해도 이전 값을 가져온다. 이는 MVCC 덕분에 가능하다.
